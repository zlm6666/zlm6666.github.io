<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>æç®€Markdowné˜…è¯»å™¨</title>
    <style>
        /* åŸºç¡€å˜é‡ï¼šäº®è‰²ä¸»é¢˜ */
        :root {
            --bg-primary: #ffffff;
            --text-primary: #2d3748;
            --bg-secondary: #f7fafc;
            --border-color: #e2e8f0;
            --progress-bg: #edf2f7;
            --progress-fill: #4299e1;
            --font-size: 16px;
            --header-height: 50px;
            --footer-height: 50px;
            --transition: 0.3s ease;
        }

        /* æš—è‰²ä¸»é¢˜å˜é‡ */
        [data-theme="dark"] {
            --bg-primary: #1a202c;
            --text-primary: #e2e8f0;
            --bg-secondary: #2d3748;
            --border-color: #4a5568;
            --progress-bg: #2d3748;
            --progress-fill: #63b3ed;
        }

        /* å…¨å±€é‡ç½® */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: var(--bg-primary);
            color: var(--text-primary);
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            font-size: var(--font-size);
            line-height: 1.75;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            padding-top: var(--header-height);
            padding-bottom: var(--footer-height);
        }

        /* é¡¶æ æ ·å¼ */
        .header {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: var(--header-height);
            background: var(--bg-secondary);
            border-bottom: 1px solid var(--border-color);
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 20px;
            z-index: 100;
            transition: transform var(--transition);
        }

        .header.hidden {
            transform: translateY(-100%);
        }

        .header-title {
            font-size: 18px;
            font-weight: 600;
        }

        .control-btn {
            background: none;
            border: none;
            color: var(--text-primary);
            font-size: 18px;
            cursor: pointer;
            padding: 5px;
        }

        /* è¿›åº¦æ¡ */
        .progress-container {
            position: fixed;
            top: var(--header-height);
            left: 0;
            width: 100%;
            height: 3px;
            background: var(--progress-bg);
            z-index: 99;
        }

        .progress-bar {
            height: 100%;
            background: var(--progress-fill);
            width: 0%;
            transition: width 0.1s linear;
        }

        /* å†…å®¹åŒº */
        .content {
            flex: 1;
            padding: 20px;
            overflow-y: auto;
            -webkit-overflow-scrolling: touch;
        }

        /* Markdownæ ·å¼ä¼˜åŒ– */
        .content h1 { font-size: 1.5rem; margin: 1.5rem 0 1rem; }
        .content h2 { font-size: 1.3rem; margin: 1.2rem 0 0.8rem; }
        .content p { margin-bottom: 1rem; }
        .content code { background: var(--bg-secondary); padding: 2px 4px; border-radius: 4px; }
        .content pre { background: var(--bg-secondary); padding: 1rem; border-radius: 8px; overflow-x: auto; }
        .content blockquote { border-left: 4px solid var(--progress-fill); padding-left: 1rem; margin: 1rem 0; opacity: 0.8; }
        .content ul { margin: 1rem 0; padding-left: 2rem; }
        .content ol { margin: 1rem 0; padding-left: 2rem; }
        .content li { margin: 0.5rem 0; }
        .content strong { font-weight: bold; }
        .content em { font-style: italic; }
        .content u { text-decoration: underline; }
        .content del { text-decoration: line-through; }

        /* åº•æ  */
        .footer {
            position: fixed;
            bottom: 0;
            left: 0;
            width: 100%;
            height: var(--footer-height);
            background: var(--bg-secondary);
            border-top: 1px solid var(--border-color);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 100;
            transition: transform var(--transition);
        }

        .footer.hidden {
            transform: translateY(100%);
        }

        /* å­—ä½“æ»‘å— */
        .font-slider {
            width: 100px;
            -webkit-appearance: none;
            background: var(--border-color);
            border-radius: 5px;
            outline: none;
        }

        .font-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            background: var(--progress-fill);
            border-radius: 50%;
            cursor: pointer;
        }

        /* å“åº”å¼è°ƒæ•´ */
        @media (max-width: 768px) {
            .header { padding: 0 15px; }
            .content { padding: 15px; }
            .font-slider { width: 80px; }
        }

        @media (max-width: 480px) {
            .header-title { font-size: 16px; }
            .control-btn { font-size: 16px; }
        }
    </style>
</head>
<body>
    <!-- é¡¶æ  -->
    <header class="header">
        <div class="header-title">é˜…è¯»å™¨</div>
        <div class="header-controls">
            <button class="control-btn" id="themeToggle" title="åˆ‡æ¢ä¸»é¢˜">ğŸŒ™</button>
            <input type="range" class="font-slider" id="fontSizeSlider" min="12" max="24" value="16" title="è°ƒæ•´å­—ä½“">
        </div>
    </header>

    <!-- è¿›åº¦æ¡ -->
    <div class="progress-container">
        <div class="progress-bar" id="progressBar"></div>
    </div>

    <!-- å†…å®¹åŒº -->
    <main class="content" id="content"></main>

    <!-- åº•æ ï¼ˆä»…ä½œå ä½ï¼Œå¯ç•™ç©ºï¼‰ -->
    <footer class="footer hidden"></footer>

    <script>
        // Markdownè§£æå™¨ç±»
        class CustomMarkdownParser {
            constructor() {
                this.regexCache = {
                    escape: /\\([\\*_~#+\-])/g,
                    bold: /\*\*([^*]+?)\*\*/g,
                    italic: /\*([^*]+?)\*/g,
                    boldItalic: /\*\*\*([^*]+?)\*\*\*/g,
                    underline: /_([^_]+?)_/g,
                    strikethrough: /-([^-]+?)-/g,
                    heading: /^(#{1,6})\s+(.+)$/gm,
                    blockquote: /^(>+)\s+(.+)$/gm,
                    unorderedList: /^(\++)\s+(.+)$/gm,
                    orderedList: /^(\d+\.)\s+(.+)$/gm,
                    inlineCode: /~([^~]+?)~/g,
                    codeBlock: /~~~([\s\S]*?)~~~/g,
                    colorTag: /<([a-z0-9#]+)>([\s\S]*?)<\/\1>/gi,
                    link: /\[([^\]]+)\]\(([^)]+)\)/g,
                    image: /!\[([^\]]+)\]\(([^)]+)\)/g
                };
            }

            parse(markdown) {
                if (!markdown) return '';
                
                let parsed = this.parseEscapes(markdown);
                parsed = this.parseCodeBlocks(parsed);
                parsed = this.parseBlockElements(parsed);
                parsed = this.parseInlineElements(parsed);
                
                return parsed;
            }

            parseEscapes(input) {
                return input.replace(this.regexCache.escape, (match, char) => {
                    return char;
                });
            }

            parseCodeBlocks(input) {
                return input.replace(this.regexCache.codeBlock, (match, code) => {
                    return `<pre><code>${this.escapeHtml(code.trim())}</code></pre>`;
                });
            }

            parseBlockElements(input) {
                const lines = input.split('\n');
                let output = [];
                let currentBlock = '';

                for (let i = 0; i < lines.length; i++) {
                    const line = lines[i].trim();
                    
                    if (line === '') {
                        if (currentBlock) {
                            output.push(this.processBlockLine(currentBlock));
                            currentBlock = '';
                        }
                        output.push('');
                        continue;
                    }

                    const isHeading = this.regexCache.heading.test(line);
                    const isBlockquote = this.regexCache.blockquote.test(line);
                    const isUnorderedList = this.regexCache.unorderedList.test(line);
                    const isOrderedList = this.regexCache.orderedList.test(line);

                    if (isHeading) {
                        if (currentBlock) {
                            output.push(this.processBlockLine(currentBlock));
                            currentBlock = '';
                        }
                        output.push(this.parseHeading(line));
                    } 
                    else if (isBlockquote) {
                        if (currentBlock) {
                            output.push(this.processBlockLine(currentBlock));
                            currentBlock = '';
                        }
                        output.push(this.parseBlockquote(line));
                    } 
                    else if (isUnorderedList) {
                        if (currentBlock) {
                            output.push(this.processBlockLine(currentBlock));
                            currentBlock = '';
                        }
                        output.push(this.parseUnorderedListItem(line));
                    } 
                    else if (isOrderedList) {
                        if (currentBlock) {
                            output.push(this.processBlockLine(currentBlock));
                            currentBlock = '';
                        }
                        output.push(this.parseOrderedListItem(line));
                    } 
                    else {
                        currentBlock += (currentBlock ? '\n' : '') + line;
                    }
                }

                if (currentBlock) {
                    output.push(this.processBlockLine(currentBlock));
                }

                return output.join('\n');
            }

            parseInlineElements(input) {
                let parsed = input;
                
                parsed = this.parseBold(parsed);
                parsed = this.parseItalic(parsed);
                parsed = this.parseBoldItalic(parsed);
                parsed = this.parseUnderline(parsed);
                parsed = this.parseStrikethrough(parsed);
                parsed = this.parseInlineCode(parsed);
                parsed = this.parseColorTags(parsed);
                parsed = this.parseLinks(parsed);
                parsed = this.parseImages(parsed);
                
                return parsed;
            }

            processBlockLine(line) {
                if (line.trim()) {
                    return `<p>${this.parseInlineElements(line)}</p>`;
                }
                return '';
            }

            parseHeading(line) {
                const match = line.match(this.regexCache.heading);
                if (match) {
                    const level = match[1].length;
                    const text = match[2];
                    return `<h${level}>${this.parseInlineElements(text)}</h${level}>`;
                }
                return line;
            }

            parseBlockquote(line) {
                const match = line.match(this.regexCache.blockquote);
                if (match) {
                    const content = match[2];
                    return `<blockquote>${this.parseInlineElements(content)}</blockquote>`;
                }
                return line;
            }

            parseUnorderedListItem(line) {
                const match = line.match(this.regexCache.unorderedList);
                if (match) {
                    const content = match[2];
                    return `<ul><li>${this.parseInlineElements(content)}</li></ul>`;
                }
                return line;
            }

            parseOrderedListItem(line) {
                const match = line.match(this.regexCache.orderedList);
                if (match) {
                    const content = match[2];
                    return `<ol><li>${this.parseInlineElements(content)}</li></ol>`;
                }
                return line;
            }

            parseBold(text) {
                return text.replace(this.regexCache.bold, '<strong>$1</strong>');
            }

            parseItalic(text) {
                return text.replace(this.regexCache.italic, '<em>$1</em>');
            }

            parseBoldItalic(text) {
                return text.replace(this.regexCache.boldItalic, '<strong><em>$1</em></strong>');
            }

            parseUnderline(text) {
                return text.replace(this.regexCache.underline, '<u>$1</u>');
            }

            parseStrikethrough(text) {
                return text.replace(this.regexCache.strikethrough, '<del>$1</del>');
            }

            parseInlineCode(text) {
                return text.replace(this.regexCache.inlineCode, '<code>$1</code>');
            }

            parseColorTags(text) {
                return text.replace(this.regexCache.colorTag, (match, color, content) => {
                    const normalizedColor = color.toLowerCase();
                    let cssColor = normalizedColor;
                    
                    if (/^#[0-9a-f]{6}$/i.test(normalizedColor)) {
                        cssColor = normalizedColor;
                    } else {
                        const colorMap = {
                            red: '#FF0000', green: '#00FF00', blue: '#0000FF',
                            yellow: '#FFFF00', purple: '#800080', cyan: '#00FFFF',
                            magenta: '#FF00FF', orange: '#FFA500', pink: '#FFC0CB',
                            brown: '#A52A2A', black: '#000000', white: '#FFFFFF',
                            gray: '#808080', grey: '#808080'
                        };
                        cssColor = colorMap[normalizedColor] || '#000000';
                    }
                    
                    return `<span style="color: ${cssColor}">${this.parseInlineElements(content)}</span>`;
                });
            }

            parseLinks(text) {
                return text.replace(this.regexCache.link, '<a href="$2" target="_blank" rel="noopener">$1</a>');
            }

            parseImages(text) {
                return text.replace(this.regexCache.image, '');
            }

            escapeHtml(text) {
                const div = document.createElement('div');
                div.textContent = text;
                return div.innerHTML;
            }
        }

        // åº”ç”¨çŠ¶æ€ç®¡ç†
        const state = {
            theme: localStorage.getItem('theme') || (window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light'),
            fontSize: localStorage.getItem('fontSize') || '16',
            isScrolling: false,
            hideTimeout: null
        };

        // DOMå…ƒç´ ç¼“å­˜
        const el = {
            body: document.body,
            header: document.querySelector('.header'),
            footer: document.querySelector('.footer'),
            content: document.getElementById('content'),
            progressBar: document.getElementById('progressBar'),
            themeToggle: document.getElementById('themeToggle'),
            fontSizeSlider: document.getElementById('fontSizeSlider')
        };

        // åˆå§‹åŒ–åº”ç”¨
        function init() {
            applyTheme(state.theme);
            applyFontSize(state.fontSize);
            loadMarkdown();
            bindEvents();
        }

        // ä¸»é¢˜æ§åˆ¶
        function applyTheme(theme) {
            el.body.setAttribute('data-theme', theme);
            el.themeToggle.textContent = theme === 'dark' ? 'â˜€ï¸' : 'ğŸŒ™';
        }

        // å­—ä½“æ§åˆ¶
        function applyFontSize(size) {
            document.documentElement.style.setProperty('--font-size', `${size}px`);
            el.fontSizeSlider.value = size;
        }

        // åŠ è½½Markdownå†…å®¹
        async function loadMarkdown() {
            try {
                const res = await fetch('./mtp/txt/gg1.txt');
                if (!res.ok) throw new Error(`åŠ è½½å¤±è´¥ï¼š${res.status}`);
                const mdText = await res.text();
                const parser = new CustomMarkdownParser();
                el.content.innerHTML = parser.parse(mdText);
            } catch (err) {
                console.error('åŠ è½½Markdownå¤±è´¥:', err);
                el.content.innerHTML = `<p style="color: red;">å†…å®¹åŠ è½½å¤±è´¥ï¼š${err.message}</p>`;
            }
        }

        // äº‹ä»¶ç»‘å®š
        function bindEvents() {
            // ä¸»é¢˜åˆ‡æ¢
            el.themeToggle.addEventListener('click', () => {
                state.theme = state.theme === 'dark' ? 'light' : 'dark';
                localStorage.setItem('theme', state.theme);
                applyTheme(state.theme);
            });

            // å­—ä½“å¤§å°è°ƒæ•´
            el.fontSizeSlider.addEventListener('input', (e) => {
                state.fontSize = e.target.value;
                localStorage.setItem('fontSize', state.fontSize);
                applyFontSize(state.fontSize);
            });

            // æ»šåŠ¨äº‹ä»¶
            window.addEventListener('scroll', handleScroll);

            // ç‚¹å‡»å±å¹•æ˜¾ç¤ºæ§åˆ¶æ 
            el.body.addEventListener('click', handleBodyClick);
        }

        // å¤„ç†æ»šåŠ¨
        function handleScroll() {
            const scrollTop = window.pageYOffset;
            const scrollHeight = document.documentElement.scrollHeight;
            const clientHeight = document.documentElement.clientHeight;

            // æ›´æ–°è¿›åº¦æ¡
            const progress = (scrollTop / (scrollHeight - clientHeight)) * 100;
            el.progressBar.style.width = `${Math.min(progress, 100)}%`;

            // æ§åˆ¶é¡¶æ /åº•æ éšè—
            if (scrollTop > 10) {
                el.header.classList.add('hidden');
                el.footer.classList.add('hidden');
                state.isScrolling = true;
            } else {
                el.header.classList.remove('hidden');
                state.isScrolling = false;
            }
        }

        // å¤„ç†ç‚¹å‡»å±å¹•
        function handleBodyClick() {
            el.header.classList.remove('hidden');
            el.footer.classList.remove('hidden');

            if (state.hideTimeout) clearTimeout(state.hideTimeout);

            state.hideTimeout = setTimeout(() => {
                if (!state.isScrolling) {
                    el.header.classList.add('hidden');
                    el.footer.classList.add('hidden');
                }
            }, 2000);
        }

        // å¯åŠ¨åº”ç”¨
        init();
    </script>
</body>
</html>
